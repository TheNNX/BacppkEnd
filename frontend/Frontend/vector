#pragma once

#include <cstddef>
#include <string>

namespace std
{
    struct string;

    template<typename T>
    struct allocator
    {
        using value_type = T;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;

        T* allocate(std::size_t count)
        {
            return new T[size];
        }

        void deallocatee(T* ptr, std::size_t count)
        {
            delete[] ptr;
        }
    };

    struct out_of_range
    {
        out_of_range(const std::string& what) {};
        /* TODO */
    };

    template<class T, class Allocator = std::allocator<T>>
    struct vector
    {
        using value_type = T;
        using allocator_type = Allocator;
        using reference = T&;
        using const_reference = const T&;
        using pointer = T*;
        using const_pointer = const T*;
    
    private:
        T* m_Impl;
        size_t m_Size;
        size_t m_ReservedSize;

    public:
        /* TODO */
        size_t size() const
        {
            return 0;
        }

        const_reference at(size_t index) const
        {
            if (index >= size())
            {
                throw std::out_of_range("");
            }
            return m_Impl[index];
        }

        reference at(size_t index)
        {
            return m_Impl[index];
        }

        reference operator[](size_t index)
        {
            return at(index);
        }
    };
}